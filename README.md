# PEMPS
Phylogenetic Evolution of Metabolic Pathway Simulator

### Overview
There are updates due to this project, but it is mostly complete. The idea came from Dr. David Liberles, and this research is being conducted through his research group in the Center for Computational Genetics and Genomics at Temple University. This Python program simulates the evolution of an input metabolic pathway over an input phylogeny and reports the changes in model parameters along the lineages of the phylogenetic tree over evolutionary time. The program calculates the steady-state flux of products of the network and allows the user to designate on which of these output fluxes selection is to act (i.e., from which fluxes population fitness will be calculated). Modeling the evolution of metabolic pathways could improve understanding of the genotype-phenotype map, which would help both distinguish compensatory changes from directional selection and detect single nucleotide polymorphisms and fixed differences that could affect phenotype, ultimately enabling detection of lineage-specific selection on metabolic pathways as well as inference of ancestral states at phylogenetic tree nodes for metabolic pathway function (Orlenko et al., 2016). The first step in developing such an inference tool is building a model for simulation. 

### User inputs and metabolic model
To run the program in the Linux command line, the user must import an sbml file into Copasi GUI and check the 'update model' and 'executable' options in the steady state task, as well as specify a text output file (deselecting both 'confirm overwrite' and 'append'). This allows subprocess to issue shell commands to Copasi for the calculation of steady state. In a text file, the user specifies the name of the Copasi and output files, the reaction flux(es) on which selection operates and the relative weights (summing to 1) of their effects on fitness, the population size(s) and ploidy, the parameters to be excluded from mutation (if any), the number of simulations to run,  and the numbers of generations to equilibrate and branch (this will be updated to be automatically calculated from the tree). Additionally, a note can be added to the experimental output file; and if a model from a previous equilibration is desired to be re-run, extended, or simulated through a different tree, the experimental file can be specified. 

### Phylogeny
The phylogeny is extracted from a Newick string and a tree object (object-oriented programming) is constructed over which the simulation can proceed recursively. The tree must be rooted, and dendropy is used to generate an ascii plot before simulating (Sukumaran & Holder, 2010). The program requires branch lengths to determine the number of generations to simulate for each branch. Population sizes for each branch can be entered individually, or the user can decide to assign the same value to all branches. Before the simulation runs through the tree, model parameters of the “root” population will be allowed to equilibrate (i.e., reach values that remain stable over many generations). This ensures that (most) model parameters do not show systematic directional change among branching populations. 

### Mutation-selection modeling framework
In each generation, each parameter has a small probability (Poisson random variable, lambda = 0.003) of mutating, and if mutation occurs the steady state flux is recalculated with new parameters. To model the tendency towards slightly deleterious change, mutational effects are drawn from a normal distribution centered at -1% for all parameters except binding constants (1%), because poorer binding corresponds to a larger Km value. Fixation probabilities are calculated using Kimura's formula (Otto and Whitlock, 2008) using the selection coefficient determined with the fitness ratio of the population before and after mutation. To speed simulation, neutral mutations (with no fitness effect) have a probability of 0.5 to fix, instead of the original 1/(ploidy * population size). Based on the results of previous simulations of this type (Orlenko, Teufel, et al., 2016), it is expected that unlike other model parameters, most binding constants will continue to show systematic directional movement. 

Included are the program, sample input files, and two sample output files (branching population fitness and heatmap of normalized percent differences for each model parameter). 
